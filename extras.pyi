# Stubs for psycopg2.extras (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from psycopg2._psycopg import ReplicationConnection as _replicationConnection, ReplicationCursor as _replicationCursor
from psycopg2.extensions import connection as _connection, cursor as _cursor
from typing import Any, Optional


class DictCursorBase(_cursor):
    row_factory: Any = ...

    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

    def fetchone(self): ...

    def fetchmany(self, size: Optional[Any] = ...): ...

    def fetchall(self): ...

    def __iter__(self): ...


class DictConnection(_connection):
    def cursor(self, *args: Any, **kwargs: Any): ...


class DictCursor(DictCursorBase):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    index: Any = ...

    def execute(self, query: Any, vars: Optional[Any] = ...): ...

    def callproc(self, procname: Any, vars: Optional[Any] = ...): ...


class DictRow(list):
    def __init__(self, cursor: Any) -> None: ...

    def __getitem__(self, x: Any): ...

    def __setitem__(self, x: Any, v: Any) -> None: ...

    def items(self): ...

    def keys(self): ...

    def values(self): ...

    def has_key(self, x: Any): ...

    def get(self, x: Any, default: Optional[Any] = ...): ...

    def iteritems(self) -> None: ...

    def iterkeys(self): ...

    def itervalues(self): ...

    def copy(self): ...

    def __contains__(self, x: Any): ...


class RealDictConnection(_connection):
    def cursor(self, *args: Any, **kwargs: Any): ...


class RealDictCursor(DictCursorBase):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    column_mapping: Any = ...

    def execute(self, query: Any, vars: Optional[Any] = ...): ...

    def callproc(self, procname: Any, vars: Optional[Any] = ...): ...


class RealDictRow(dict):
    def __init__(self, cursor: Any) -> None: ...

    def __setitem__(self, name: Any, value: Any): ...


class NamedTupleConnection(_connection):
    def cursor(self, *args: Any, **kwargs: Any): ...


class NamedTupleCursor(_cursor):
    Record: Any = ...

    def execute(self, query: Any, vars: Optional[Any] = ...): ...

    def executemany(self, query: Any, vars: Any): ...

    def callproc(self, procname: Any, vars: Optional[Any] = ...): ...

    def fetchone(self): ...

    def fetchmany(self, size: Optional[Any] = ...): ...

    def fetchall(self): ...

    def __iter__(self): ...


class LoggingConnection(_connection):
    log: Any = ...

    def initialize(self, logobj: Any) -> None: ...

    def filter(self, msg: Any, curs: Any): ...

    def cursor(self, *args: Any, **kwargs: Any): ...


class LoggingCursor(_cursor):
    def execute(self, query: Any, vars: Optional[Any] = ...): ...

    def callproc(self, procname: Any, vars: Optional[Any] = ...): ...


class MinTimeLoggingConnection(LoggingConnection):
    def initialize(self, logobj: Any, mintime: int = ...) -> None: ...

    def filter(self, msg: Any, curs: Any): ...

    def cursor(self, *args: Any, **kwargs: Any): ...


class MinTimeLoggingCursor(LoggingCursor):
    timestamp: Any = ...

    def execute(self, query: Any, vars: Optional[Any] = ...): ...

    def callproc(self, procname: Any, vars: Optional[Any] = ...): ...


class LogicalReplicationConnection(_replicationConnection):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...


class PhysicalReplicationConnection(_replicationConnection):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...


class StopReplication(Exception):
    ...


class ReplicationCursor(_replicationCursor):
    def create_replication_slot(
        self, slot_name: Any, slot_type: Optional[Any] = ..., output_plugin: Optional[Any] = ...) -> None: ...

    def drop_replication_slot(self, slot_name: Any) -> None: ...

    def start_replication(self, slot_name: Optional[Any] = ..., slot_type: Optional[Any] = ...,
                          start_lsn: int = ..., timeline: int = ..., options: Optional[Any] = ..., decode: bool = ...) -> None: ...

    def fileno(self): ...


class UUID_adapter:
    def __init__(self, uuid: Any) -> None: ...

    def __conform__(self, proto: Any): ...

    def getquoted(self): ...


def register_uuid(oids: Optional[Any] = ..., conn_or_curs: Optional[Any] = ...): ...


class Inet:
    addr: Any = ...

    def __init__(self, addr: Any) -> None: ...

    def prepare(self, conn: Any) -> None: ...

    def getquoted(self): ...

    def __conform__(self, proto: Any): ...


def register_inet(oid: Optional[Any] = ..., conn_or_curs: Optional[Any] = ...): ...


def register_tstz_w_secs(oids: Optional[Any] = ..., conn_or_curs: Optional[Any] = ...) -> None: ...


def wait_select(conn: Any) -> None: ...


class HstoreAdapter:
    wrapped: Any = ...

    def __init__(self, wrapped: Any) -> None: ...
    conn: Any = ...
    getquoted: Any = ...

    def prepare(self, conn: Any) -> None: ...

    @classmethod
    def parse(self, s: Any, cur: Any, _bsdec: Any = ...): ...

    @classmethod
    def parse_unicode(self, s: Any, cur: Any): ...

    @classmethod
    def get_oids(self, conn_or_curs: Any): ...


def register_hstore(conn_or_curs: Any, globally: bool = ..., str: bool = ...,
                    oid: Optional[Any] = ..., array_oid: Optional[Any] = ...) -> None: ...


class CompositeCaster:
    name: Any = ...
    schema: Any = ...
    oid: Any = ...
    array_oid: Any = ...
    attnames: Any = ...
    atttypes: Any = ...
    typecaster: Any = ...
    array_typecaster: Any = ...

    def __init__(self, name: Any, oid: Any, attrs: Any, array_oid: Optional[Any] = ..., schema: Optional[Any] = ...) -> None: ...

    def parse(self, s: Any, curs: Any): ...

    def make(self, values: Any): ...

    @classmethod
    def tokenize(self, s: Any): ...


def register_composite(name: Any, conn_or_curs: Any, globally: bool = ..., factory: Optional[Any] = ...): ...


def execute_batch(cur: Any, sql: Any, argslist: Any, page_size: int = ...) -> None: ...


def execute_values(cur: Any, sql: Any, argslist: Any, template: Optional[Any] = ..., page_size: int = ...) -> None: ...
